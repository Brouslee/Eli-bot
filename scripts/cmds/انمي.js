module.exports = {
  config: {
    name: "Ù†Ø¨Ø°Ø©",
    aliases: ["Ø§Ù†Ù…ÙŠ", "ØºÙ„Ø§Ù-Ø§Ù†Ù…ÙŠ"],
    version: "1.1.0",
    author: "Mikey + ØªØ¹Ø¯ÙŠÙ„ SIFOANTER",
    shortDescription: "Ø¬Ù„Ø¨ ØºÙ„Ø§Ù Ø£Ù†Ù…ÙŠ ÙˆÙ…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙØµÙ„Ø© Ù…Ø¹ Ø§Ù„Ù‚ØµØ© Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
    longDescription: "ÙŠØ¨Ø­Ø« Ø¹Ù† Ø£Ù†Ù…ÙŠ Ø¨Ø§Ù„Ø§Ø³Ù… ÙˆÙŠØ±Ø³Ù„ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù Ù…Ø¹ ØªÙØ§ØµÙŠÙ„ ÙƒØ§Ù…Ù„Ø© + Ø§Ù„Ù‚ØµØ© Ù…ØªØ±Ø¬Ù…Ø© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ©",
    category: "Ø§Ù„ÙˆØ³Ø§Ø¦Ø·",
    guide: {
      ar: "Ù†Ø¨Ø°Ø© <Ø§Ø³Ù… Ø§Ù„Ø£Ù†Ù…ÙŠ>\nÙ…Ø«Ø§Ù„: Ù†Ø¨Ø°Ø© Ù†Ø§Ø±ÙˆØªÙˆ\nØ¥Ø°Ø§ ØªØ¹Ø¯Ø¯Øª Ø§Ù„Ù†ØªØ§Ø¦Ø¬: Ø§Ø®ØªØ± Ø¨Ø§Ù„Ø±Ø¯ Ø¨Ø±Ù‚Ù…"
    }
  },
  langs: {
    ar: {
      askName: "â–¸ â—‰ Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„Ù„ÙŠ ØªØ¨ÙŠÙ‡:",
      searching: "â–¸ â—‰ Ù†Ø¨Ø­Ø« Ø¹Ù„Ù‰: %1...",
      notFound: "â–¸ â—‰ Ù…Ø§ Ù„Ù‚ÙŠÙ†Ø§ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø¨Ø­Ø«: %1",
      chooseHeader: "â–¸ â—‰ Ù„Ù‚ÙŠÙ†Ø§ %1 Ù†ØªØ§Ø¦Ø¬ØŒ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:",
      chooseList: "%1\n\nâ”‚ Ø±Ø¯Ù‘ Ø¨Ø±Ù‚Ù… Ù…Ù† 1 Ø¥Ù„Ù‰ %2 Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£Ù†Ù…ÙŠ",
      invalidNumber: "â–¸ â—‰ Ø±Ù‚Ù… ØºÙŠØ± ØµØ§Ù„Ø­\nâ”‚ Ø§Ø®ØªÙØ± Ø¨ÙŠÙ† 1 Ùˆ%1",
      notAllowed: "â–¸ â—‰ Ù‡Ø°Ø§ Ø§Ù„Ø±Ø¯Ù‘ Ù…Ø®ØµÙ‘Øµ Ù„Ù„ÙŠ Ø§Ø³ØªØ¹Ù…Ù„ Ø§Ù„Ø£Ù…Ø± ÙÙ‚Ø·",
      preparing: "â–¸ â—‰ Ù†Ø¬Ù‡Ù‘Ø² Ø§Ù„ØºÙ„Ø§Ù ÙˆØ§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª...",
      detail: "ğŸ“Œ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: %1\nğŸŒ Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠØ©: %2\nğŸ“º Ø§Ù„Ù†ÙˆØ¹: %3\nğŸ“¡ Ø§Ù„Ø­Ø§Ù„Ø©: %4\nğŸ—“ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆÙ„: %5\nâ° Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©: %6\nğŸ“… Ø§Ù„Ø¨Ø«: %7\nğŸ¬ Ø§Ù„Ù…Ù†ØªØ¬ÙŠÙ†: %8\nğŸ¢ Ø§Ù„Ø§Ø³ØªÙˆØ¯ÙŠÙˆ: %9\nğŸ“– Ø§Ù„Ù…ØµØ¯Ø±: %10\nğŸ Ø§Ù„Ø­Ù„Ù‚Ø§Øª: %11\nâ³ Ø§Ù„Ù…Ø¯Ø©: %12\nğŸ· Ø§Ù„Ø£Ù†ÙˆØ§Ø¹: %13\nğŸ”¥ Ø§Ù„Ø´Ø¹Ø¨ÙŠØ©: %14\nâ­ Ø§Ù„ØªØµÙ†ÙŠÙ: %15\nğŸ’¯ Ø§Ù„Ù†ØªÙŠØ¬Ø©: %16\nğŸ” Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: %17",
      synopsisBlock: "\nğŸ§¾ Ø§Ù„Ù‚ØµØ©:\n%1",
      unknown: "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ",
      none: "Ù„Ø§ ÙŠÙˆØ¬Ø¯",
      error: "â–¸ â—‰ ØµØ§Ø± Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø¨\nâ”‚ Ø¬Ø±Ù‘Ø¨ Ù…Ù† Ø¨Ø¹Ø¯"
    }
  },
  onStart: async function({ message, event, args, getLang }) {
    const axios = require("axios");
    const query = (args || []).join(" ").trim();
    if (!query) {
      const sent = await message.reply(getLang("askName"));
      return global.GoatBot.onReply.set(sent.messageID, {
        commandName: this.config.name,
        type: "askName",
        author: event.senderID,
        messageID: sent.messageID
      });
    }
    await message.reply(getLang("searching", query));
    try {
      const { data } = await axios.get("https://api.jikan.moe/v4/anime", {
        params: { q: query, limit: 5, sfw: true },
        timeout: 20000
      });
      const results = Array.isArray(data?.data) ? data.data : [];
      if (!results.length) return message.reply(getLang("notFound", query));
      if (results.length === 1) {
        return sendDetail(results[0], message, getLang);
      } else {
        const list = results.map((a, i) => {
          const title = a.title || getLang("unknown");
          const year = a.year || (a.aired?.prop?.from?.year || getLang("unknown"));
          const type = a.type || getLang("unknown");
          const score = typeof a.score === "number" ? a.score.toFixed(1) : getLang("unknown");
          return `${i + 1}. ${title} â€¢ ${type} â€¢ ${year} â€¢ â­ ${score}`;
        }).join("\n");
        const prompt = await message.reply(
          getLang("chooseHeader", results.length) + "\n" +
          getLang("chooseList", list, results.length)
        );
        global.GoatBot.onReply.set(prompt.messageID, {
          commandName: this.config.name,
          type: "choose",
          author: event.senderID,
          results,
          messageID: prompt.messageID
        });
      }
    } catch {
      return message.reply(getLang("error"));
    }

    async function sendDetail(anime, message, getLang) {
      const axios = require("axios");
      await message.reply(getLang("preparing"));
      try {
        const unk = getLang("unknown");
        const none = getLang("none");
        const title = anime.title || unk;
        const jp = anime.title_japanese || unk;
        const type = anime.type || unk;
        const status = anime.status || unk;
        const premier = formatPremier(anime.season, anime.year, unk);
        const broadcast = anime.broadcast?.string || formatBroadcast(anime.broadcast) || unk;
        const aired = anime.aired?.string || unk;
        const producers = formatList(anime.producers, none);
        const studios = formatList(anime.studios, none);
        const source = anime.source || unk;
        const episodes = typeof anime.episodes === "number" ? String(anime.episodes) : unk;
        const duration = anime.duration || unk;
        const genres = formatGenres(anime, none);
        const popularity = typeof anime.popularity === "number" ? String(anime.popularity) : unk;
        const rank = typeof anime.rank === "number" ? `#${anime.rank}` : unk;
        const score = typeof anime.score === "number" ? anime.score.toFixed(1) : unk;
        const rating = anime.rating || unk;

        let synopsis = (anime.synopsis || "").trim();
        if (!synopsis) synopsis = getLang("unknown");
        let ar = synopsis === getLang("unknown") ? synopsis : await translateText(synopsis, "ar");
        if (ar && ar.length > 1200) ar = ar.slice(0, 1200).trim() + " ...";

        const info = getLang("detail",
          title,
          jp,
          type,
          status,
          premier,
          broadcast,
          aired,
          producers,
          studios,
          source,
          episodes,
          duration,
          genres,
          popularity,
          rank,
          score,
          rating
        );
        const body = info + getLang("synopsisBlock", ar);

        const img = anime.images?.jpg?.large_image_url || anime.images?.webp?.large_image_url || anime.images?.jpg?.image_url;
        if (img) {
          const pic = await axios.get(img, { responseType: "stream", timeout: 20000 });
          return message.reply({ body, attachment: pic.data });
        } else {
          return message.reply(body);
        }
      } catch {
        return message.reply(getLang("error"));
      }
    }

    function formatPremier(season, year, unk) {
      if (!season && !year) return unk;
      const map = { winter: "Ø´ØªØ§Ø¡", spring: "Ø±Ø¨ÙŠØ¹", summer: "ØµÙŠÙ", fall: "Ø®Ø±ÙŠÙ" };
      const s = season ? (map[String(season).toLowerCase()] || season) : "";
      if (s && year) return `${s} ${year}`;
      return String(year || s || unk);
    }
    function formatBroadcast(bc) {
      if (!bc) return "";
      const parts = [];
      if (bc.day) parts.push(bc.day);
      if (bc.time) parts.push(bc.time);
      if (bc.timezone) parts.push(bc.timezone);
      return parts.join(" ");
    }
    function formatList(arr, none) {
      if (!Array.isArray(arr) || !arr.length) return none;
      return arr.map(x => x?.name).filter(Boolean).join(", ");
    }
    function formatGenres(anime, none) {
      const getNames = (a) => (Array.isArray(a) ? a.map(x => x?.name).filter(Boolean) : []);
      const out = [...getNames(anime.genres), ...getNames(anime.themes), ...getNames(anime.demographics)];
      return out.length ? out.join(", ") : none;
    }
  },
  onReply: async function({ message, event, Reply, getLang }) {
    if (!Reply || !Reply.type) return;
    if (event.senderID !== Reply.author) return message.reply(getLang("notAllowed"));
    const axios = require("axios");
    if (Reply.type === "askName") {
      const query = (event.body || "").trim();
      if (!query) return;
      try {
        await message.reply(getLang("searching", query));
        const { data } = await axios.get("https://api.jikan.moe/v4/anime", {
          params: { q: query, limit: 5, sfw: true },
          timeout: 20000
        });
        const results = Array.isArray(data?.data) ? data.data : [];
        if (!results.length) return message.reply(getLang("notFound", query));
        if (results.length === 1) {
          return sendDetail(results[0]);
        } else {
          const list = results.map((a, i) => {
            const title = a.title || getLang("unknown");
            const year = a.year || (a.aired?.prop?.from?.year || getLang("unknown"));
            const type = a.type || getLang("unknown");
            const score = typeof a.score === "number" ? a.score.toFixed(1) : getLang("unknown");
            return `${i + 1}. ${title} â€¢ ${type} â€¢ ${year} â€¢ â­ ${score}`;
          }).join("\n");
          const prompt = await message.reply(
            getLang("chooseHeader", results.length) + "\n" +
            getLang("chooseList", list, results.length)
          );
          global.GoatBot.onReply.set(prompt.messageID, {
            commandName: "Ù†Ø¨Ø°Ø©",
            type: "choose",
            author: event.senderID,
            results,
            messageID: prompt.messageID
          });
        }
      } catch {
        return message.reply(getLang("error"));
      }
    } else if (Reply.type === "choose") {
      const n = parseInt((event.body || "").trim(), 10);
      if (isNaN(n) || n < 1 || n > Reply.results.length) return message.reply(getLang("invalidNumber", Reply.results.length));
      const anime = Reply.results[n - 1];
      try {
        await message.reply(getLang("preparing"));
        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… sendDetail
        return await (async function(anime) {
          const axios = require("axios");
          const unk = getLang("unknown");
          const none = getLang("none");
          const title = anime.title || unk;
          const jp = anime.title_japanese || unk;
          const type = anime.type || unk;
          const status = anime.status || unk;
          const premier = (function(season, year) {
            const map = { winter: "Ø´ØªØ§Ø¡", spring: "Ø±Ø¨ÙŠØ¹", summer: "ØµÙŠÙ", fall: "Ø®Ø±ÙŠÙ" };
            if (!season && !year) return unk;
            const s = season ? (map[String(season).toLowerCase()] || season) : "";
            if (s && year) return `${s} ${year}`;
            return String(year || s || unk);
          })(anime.season, anime.year);
          const broadcast = anime.broadcast?.string || (function(bc) {
            if (!bc) return "";
            const parts = [];
            if (bc.day) parts.push(bc.day);
            if (bc.time) parts.push(bc.time);
            if (bc.timezone) parts.push(bc.timezone);
            return parts.join(" ");
          })(anime.broadcast) || unk;
          const aired = anime.aired?.string || unk;
          const producers = (function(arr) {
            if (!Array.isArray(arr) || !arr.length) return none;
            return arr.map(x => x?.name).filter(Boolean).join(", ");
          })(anime.producers);
          const studios = (function(arr) {
            if (!Array.isArray(arr) || !arr.length) return none;
            return arr.map(x => x?.name).filter(Boolean).join(", ");
          })(anime.studios);
          const source = anime.source || unk;
          const episodes = typeof anime.episodes === "number" ? String(anime.episodes) : unk;
          const duration = anime.duration || unk;
          const genres = (function(an) {
            const getNames = (a) => (Array.isArray(a) ? a.map(x => x?.name).filter(Boolean) : []);
            const out = [...getNames(an.genres), ...getNames(an.themes), ...getNames(an.demographics)];
            return out.length ? out.join(", ") : none;
          })(anime);
          const popularity = typeof anime.popularity === "number" ? String(anime.popularity) : unk;
          const rank = typeof anime.rank === "number" ? `#${anime.rank}` : unk;
          const score = typeof anime.score === "number" ? anime.score.toFixed(1) : unk;
          const rating = anime.rating || unk;

          let synopsis = (anime.synopsis || "").trim();
          if (!synopsis) synopsis = getLang("unknown");
          let ar = synopsis === getLang("unknown") ? synopsis : await translateText(synopsis, "ar");
          if (ar && ar.length > 1200) ar = ar.slice(0, 1200).trim() + " ...";

          const info = getLang("detail",
            title,
            jp,
            type,
            status,
            premier,
            broadcast,
            aired,
            producers,
            studios,
            source,
            episodes,
            duration,
            genres,
            popularity,
            rank,
            score,
            rating
          );
          const body = info + getLang("synopsisBlock", ar);

          const img = anime.images?.jpg?.large_image_url || anime.images?.webp?.large_image_url || anime.images?.jpg?.image_url;
          if (img) {
            const pic = await axios.get(img, { responseType: "stream", timeout: 20000 });
            await message.reply({ body, attachment: pic.data });
          } else {
            await message.reply(body);
          }
          if (Reply.messageID) global.GoatBot.onReply.delete(Reply.messageID);
        })(anime);
      } catch {
        return message.reply(getLang("error"));
      }
    }
  },
  onReaction: async function() {},
  onEvent: async function() {}
};

async function translateText(text, to) {
  const axios = require("axios");
  try {
    if (!text || !text.trim()) return "";
    const url = "https://translate.googleapis.com/translate_a/single";
    const { data } = await axios.get(url, {
      params: { client: "gtx", sl: "auto", tl: to, dt: "t", q: text },
      timeout: 15000
    });
    const parts = Array.isArray(data?.[0]) ? data[0].map(seg => seg[0]).join("") : "";
    return parts || text;
  } catch {
    return text;
  }
}